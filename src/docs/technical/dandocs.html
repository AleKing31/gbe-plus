<!DOCTYPE HTML>
<html>
	<head>
		<title>Dan Docs</title>
		<meta charset="utf-8" />

		<style type="text/css">

			body
			{
				font-family: "times new roman", serif, verdana;
				font-size: 18px;
				margin: 0px;
				background-color: #FFFFFF;
			}

			li
			{
				margin-top: 10px;
			}

			code
			{
				white-space: pre;
			}

			.gray_title
			{
				width: 100%;
				background-color: #C0C0C0;
				margin-bottom: 15px;
			}

			.list_head
			{
				margin-bottom: 0px;
			}

			.list_item
			{
				margin-top: 0px;
				margin-bottom: 0px;
			}

		</style>
	</head>

	<p class="gray_title">Dan Docs</p>

	<p class="list_head"><strong>Overview</strong></p>
	<p class="list_item"><a href="#about">About Dan Docs</a></p>

	<p class="list_head"><strong>Barcode Boy</strong></p>
	<p class="list_item"><a href="#bcb_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#bcb_gam">Compatible Games</a></p>
	<p class="list_item"><a href="#bcb_com">Barcode Boy to DMG Communication</a></p>
	<p class="list_item"><a href="#bcb_bar">Barcode Format</a></p>
	<p class="list_item"><a href="#bcb_rip">Card Dumping + Emulation</a></p>
	<p class="list_item"><a href="#bcb_err">Barcode Errors</a></p>

	<p class="list_head"><strong>Barcode Taisen Bardigun Scanner</strong></p>
	<p class="list_item"><a href="#btb_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#btb_com">Card Reader to GBC Communication</a></p>
	<p class="list_item"><a href="#btb_bar">Barcode Format</a></p>
	<p class="list_item"><a href="#btb_rip">Card Dumping</a></p>

	<p class="list_head"><strong>DMG-07 4-Player Adapter</strong></p>
	<p class="list_item"><a href="#dmg07_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#dmg07_gam">Compatible Games</a></p>
	<p class="list_item"><a href="#dmg07_pro">Link Cable Protocol</a></p>
	<p class="list_item"><a href="#dmg07_pin">Ping Phase</a></p>
	<p class="list_item"><a href="#dmg07_tra">Transmission Phase</a></p>
	<p class="list_item"><a href="#dmg07_res">Restarting Ping Phase</a></p>

	<p class="list_head"><strong>Zok Zok Heroes Full Changer</strong></p>
	<p class="list_item"><a href="#zzh_gen">General Hardware Information</a></p>
	<p class="list_item"><a href="#zzh_opr">Operation</a></p>
	<p class="list_item"><a href="#zzh_com">IR Communication</a></p>
	<p class="list_item"><a href="#zzh_cap">Capturing IR Data</a></p>
	<p class="list_item"><a href="#zzh_emu">Emulation</a></p>
	
	<p class="list_head"><strong>GBA Screen Stretch</strong></p>
	<p class="list_item"><a href="#gss_gen">General Information</a></p>

	<a name="about"></a>
	<p class="gray_title">About Dan Docs</p>

	<p>For the longest time, a technical document called Pan Docs formed the basis of nearly all known documentation about the Nintendo Game Boy. To this day, Pan Docs (or an updated version such as the GBDev wiki) continues to be the go-to source of general Game Boy information. However, while Pan Docs covers the basics well enough, it does not touch upon more obscure Game Boy hardware. Dan Docs, on the other hand, aims to fill this gap. Dan Docs is basically everything else you wanted to know about the Game Boy, but no one dared to ask.</p>

	<p>All of the data here comes from my research for the GBE+ project. Much of this information is copied+pasted from the text files I&#39;ve made over the years. For ease of use and access, however, it&#39;s been converted to a single HTML document. As more items are reverse-engineered and studied, they will be added to Dan Docs as well as GBE+.</p>

	<!-- Barcode Boy -->

	<a name="bcb_gen"></a>
	<p class="gray_title">[Barcode Boy] : General Hardware Information</p>

	<p>Appearing around 1992, the Barcode Boy is the earliest form of card-scanning on Nintendo&#39;s Game Boy line of handhelds, predating both the e-Reader and the Bardigun Taisen Reader by a number of years. Only a limited set of games made by Namcot were compatible with (or rather absolutely required) the Barcode Boy. All of the games and the Barcode Boy itself were only released in Japan.</p>

	<ul>
		<li class="list_item">Barcode Boy is a rather bulky add-on that snaps on top of the original DMG (the gray &#34;brick&#34;)</li>
		<li class="list_item">Barcode Boy requires 2 AA batteries (with a DMG-01, that brings the total to 6 AA necessary to play any Barcode Boy game)</li>
		<li class="list_item">Barcode Boy WILL NOT WORK WITH OTHER GAME BOYS! For whatever reason using the Universal Link Cable (MGB-010) will not work.</li>
		<li class="list_item">Barcode Boy games are always labeled with a &#34;B.B.&#34; logo with a little card. Apparently there are 2 types (no idea what the Red/Blue differences are)</li>
		<li class="list_item">Includes a very, very short Link Cable</li>
		<li class="list_item">Unlike the Barcode Taisen Bardigun reader, the Barcode Boy has no button. It is always &#34;ON&#34; when switched on, thus draining batteries even while not scanning</li>
	</ul>

	<a name="bcb_gam"></a>
	<p class="gray_title">[Barcode Boy] : Compatible Games</p>

	<p>Only 5 Barcode Boy games are known to exist:</p>

	<ul>
		<li class="list_item">Battle Space</li>
		<li class="list_item">Monster Maker Barcode Saga</li>
		<li class="list_item">Kattobi Road</li>
		<li class="list_item">Family Jockey 2</li>
		<li class="list_item">Famista 3</li>
	</ul>

	<a name="bcb_com"></a>
	<p class="gray_title">[Barcode Boy] : Barcode Boy to DMG Communication</p>

	<p>Each game will first try to detect if the Barcode Boy is plugged in and turned on. The Game Boy will send the bytes [0x10, 0x07, 0x10, 0x07] as part of a handshake. A properly functioning Barcode Boy will return the bytes [0xFF, 0xFF, 0x10, 0x07]. Barcode Boy games will still successfully detect the Barcode Boy scanner even if the first two bytes in the reply to the handshake aren't 0xFF, probably to simplify the game code. As a result, the first two bytes of the handshake are useless and ignored, but the last two bytes *MUST* be [0x10, 0x07]. If the Barcode Boy is plugged in but not turned on, it responds with 0x00 for the entire handshake, and the game produces an error message.</p>

	<p>After detection passes, the Game Boy will sit and wait for a response. The Game Boy, unlike how it works with other SIO devices, takes on a passive role with the Barcode Boy by switching to an external clock. The Game Boy actually requires the Barcode Boy to take the initiative when scanning. Therefore, it is assumed that the Barcode Boy uses an internal clock and drives serial communications while scanning a barcode.</p>

	<p>Nitty-gritty bits:</p>
	
	<ol>
		<li>The game logic pings the Barcode Boy with [0x10, 0x07, 0x10, 0x07]. The Barcode Boy is expected to reply; the first two bytes are not important (real hardware returns 0xFF), but the second two bytes must be [0x10, 0x07].</li>
		<li>Afterwards, the Game Boy waits for input using an external clock. What follows are two strings of numbers representing the barcode data. The &#34;numbers&#34; are represented as ASCII instead of hex.</li>
		<li>Both strings are 13-digits long and are the EAN-13 number corresponding to the barcode.</li>
		<li>Before sending each string, the Barcode Boy sends a 0x02 byte.</li>
		<li>After sending each string, the Barcode Boy sends a 0x03 byte.</li>
		<li>Altogether, the Barcode Boy transmits 30 bytes to the Game Boy.</li>
	</ol>

	<p>Overall known communication protocol:</p>

	<ul>
		<li>Handshake -&gt; Send [0x10, 0x07, 0x10, 0x07] : Receive [0xFF, 0xFF, 0x10, 0x07]</li>
		<li>Start Barcode Data Transmission -&gt; [0x02]</li>
		<li>Stop Barcode Data Transmission -&gt; [0x03]</li>
	</ul>

	<p>Standard communication flow:</p>

<code>[DMG]			[BCB]
Handshake	--->
		<---	Handshake

		<---	0x2
		<---	EAN-13
		<---	0x3

		<---	0x2
		<---	EAN-13
		<---	0x3</code>

	<p>Since the Barcode Boy acts as master (after the handshake at least), the Game Boy never initiates a transfer during barcode transmission. When sending barcode data, the Barcode Boy doesn&#39;t seem to care what value the Game Boy writes to SB, although no Barcode Boy games write to SB at that time anyway. Ultimately unknown if the Barcode Boy accepts input beyond the handshake, but no evidence has been observed to suggest otherwise.</p>

	<p>Once the Barcode Boy sends the handshake [0x10, 0x07] back to the Game Boy, the scanner returns 0xFF anytime the Game Boy tries to send additional data while the handheld is still on its own internal clock. After the Barcode Boy finishes sending back the barcode data to the Game Boy, it requires the handshake again. It appears the handshake can fail for unknown reasons (probably related to the hardware). For example, the Barcode Boy at times may send back [0x90, 0x07], which seems to indicate an error of some sort.</p>

	<a name="bcb_bar"></a>
	<p class="gray_title">[Barcode Boy] : Barcode Format</p>

	<p>The two strings are the actual barcode data in numerical form. The barcode format itself is EAN-13, and a few games use JAN-13 specifically. Older JAN-13 barcodes start off with the flag code 49. Interestingly enough, the newer JAN-13 flag code is 45 and was introduced in 1992, the same year the Barcode Boy was released. Probably due to timing or convenience, the JAN-13 barcodes on the cards stuck to the older flag code. Some Barcode Boy barcodes are technically &#34;coupons&#47;vouchers&#34; types, as they use the flag code 99 instead of 45 or 49. Family Jockey 2 and Famista 3 don't use JAN-13 specifically; instead they use random EAN-13 barcodes with varying flag codes.</p>

	<p>Using scans of the barcode @ 600 DPI, the smallest bar width is approximately 7 pixels (give or take). With that information, it&#39;s possible to recreate the EAN-13 number with a sufficient image and barcode scanning software. It should be noted that the Barcode Boy appears to do away with the center guard, however, it maintains left and right guards.</p>

	<a name="bcb_rip"></a>
	<p class="gray_title">[Barcode Boy] : Card Dumping + Emulation</p>

	<p>Amazingly simple in comparison to something like Barcode Taisen Bardigun, chiefly because such a small amount of bytes need to be sent to the Game Boy. Basically, all you need to do is convert the barcode to EAN-13. Anything capable of reading standard barcodes found on most products should be sufficient to grab the numerical form of each card.</p>

	<p>As far as emulation goes, simply convert the EAN-13 ASCII string to hex and transmit it accordingly.</p>

	<a name="bcb_err"></a>
	<p class="gray_title">[Barcode Boy] : Barcode Errors</p>

	<p>Interestingly enough, a vast majority of the barcodes for Family Jockey 2 are completely incorrect. Only 3 out of the 8 barcodes actually generate horses with the stats listed on the cards. Barcodes A1, B1, and A4 work fine; the rest give stats that do not match up with the card's. Some, such as A2, even generate horses that are totally unfit for competition (A2 produces stats with 2s and 0s, and the max is supposed to be 9 in each category). It's not clear if this was a programming glitch or a mistake Namcot made when printing the cards, or some combination of the two. All other Barcode Boy games came packaged with cards that have no issues whatsoever.</p>


	<!-- Barcode Taisen Bardigun -->

	<a name="btb_gen"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : General Hardware Information</p>

	<p>Barcode Taisen Bardigun is a Japanese Game Boy game released December 11, 1998, made by TAM. It doesn&#39;t seem like a very interesting or noteworthy game in and of itself (yet another monster breeding&#47;raising&#47;fighting&#47;collecting game). However, this game featured exclusive hardware, a card reader that scanned various barcodes</p>

	<ul>
		<li class="list_item">Barcode Taisen Bardigun (DMG-ABEJ-JPN)</li>
		<li class="list_item">MBC3 + RTC + Battery Saves (Same as Pokemon Gold and Silver)</li>
		<li class="list_item">Compatible with DMG, SGB, and GBC systems</li>
		<li class="list_item">Japanese-text only (hiragana&#47;katakana only, a bit of a blessing given 8x8 fonts are not the best for kanji)</li>
		<li class="list_item">Supports Link Cable for multiplayer</li>
		<li class="list_item">Comes with 1 card-reader powered by 3 AAA batteries</li>
		<li class="list_item">Comes with 5 cards bundled (only 3 have barcodes, the other 2 are just collectables?)</li>
		<li class="list_item">Reader connects to DMG/GBC serial port for communication</li>
	</ul>

	<a name="btb_com"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : Card Reader to GBC Communication</p>

	<p>Game Boy will initialize a transfer with an internal clock; much like every other Serial I/O device (GB Printer, GB Mobile Adapter), Game Boy sends initial data, then the reader responds. Transfer rate is 1KB&#47;s, the slowest speed, so there is no difference between DMG and GBC transfers. To begin, the Game Boy constantly sends 0xFF to the reader. The game logic times out after a few seconds if no proper response is established.</p>

	<p>To scan a card, hold it face down (barcode facing the ground and towards the reader), press the reader&#39;s button, and swipe. The scanner only seems to activate once the button is pushed (otherwise it&#39;d waste battery if it were constantly on, or constantly on and trying to receieve commands from the Game Boy). Without pressing the button, the game logic times out the scanning process after a few seconds (about 9 seconds). If an error is detected during the scan process, the reader seems to acknowledge this pretty quickly.</p>

	<p>Nitty-gritty bits</p>

	<ol>
		<li>When connected, the reader responds with 0x00 until it is prepared to send the barcode data.</li>

		<li>Afterwards, it begins processing barcode data. Data is represented serially. A bit reading &#34;1&#34; indicates that the card reader is detecting whitespace. A bit reading &#34;0&#34; indicates the card reader is detecting a black segment (black bar).</li>

		<li>The barcode sequence itself is nothing more than a continuous stream of zeroes and ones. That is to say, groups of ones and zeroes are always packed together, but the length of each group determines the length of any given bar.</li>

		<li>There doesn&#39;t appear to be a fixed number of bytes that the Game Boy seems to expect when scanning. Different scans seem to produce different amounts of data transferred to the Game Boy. This could be due to numerous reasons in the hardware (swipe speed, how clean the scanner is, some other variance within the scanner's light sensitivity). Overall, however, the most important thing seems to be the length and sequence of the bars encoded as groups of ones and zeroes.</li>

		<li>The Game Boy doesn&#39;t ever seem to send any interesting data, just 0xFF. No commands are sent. The Game Boy simply sends a byte and expects a result to come from the reader; the results are what matter and are interpreted later on.</li>

	</ol>

	<a name="btb_bar"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : Barcode Format</p>

	<p>Because the incoming barcode data is not consistent byte-for-byte, the patterns are what matters most. To illustrate this idea, below are two sets of data extracted after scanning a card (using a hacked version of Barcode Taisen Bardigun and saving all SIO communications to Cart RAM).</p>

<code>SET_1		SET_2
00 00		00 03		
7F FE		FF F8
00 01		00 03
FF FF 		FF FF
FF FF		FF FF
FF C0		FF E0
00 3F		00 0F
FF 00		FF 80
00 00		00 00
07 FF		00 FF
00 00		FC 00
FF FF		03 FF
FF C0		FF FF
00 00		C0 00</code>

<p>Each set is actually a bitstream of 0s and 1s like so:</p>

<code>Set 1 [16:0] [14:1] [15:0] [43:1] ...
Set 2 [14:0] [15:1] [14:0] [45:1] ...</code>

	<p>The patterns in the sets are roughly the same. They switch between 0s, 1s, and 0s (black, white, black) fairly quickly followed by a long segment of 1s (white) which is roughly the general pattern seen at the beginning&#47;ends of the barcodes. Based on this information, the thinest bars are about 0.0133 inches (8 pixels when scanning at 600dpi). Some further calculations based on this information:</p>

<code>Bar Width (in pixels @ 600dpi) -&gt; Estimated bit-count sent to Game Boy

8	-&gt;	~14-16
16	-&gt;	~27-29
24	-&gt;	~43-45</code>

	<p>Every 8 pixels should be approximately 15 bits worth of data sent to the Game Boy, so:</p>

	<code>Number of Pixels @ 600dpi * 1.875 = Approximate bit count</code>

	<a name="btb_rip"></a>
	<p class="gray_title">[Barcode Taisen Bardigun] : Card Dumping</p>

	<p>With the above guideline, it is possible to dump the cards by scanning them, then creating a binary file containing barcodes as alternating bitstreams of 0s and 1s. With this method, no homebrew techniques are needed, and only an image file is necessary to actually preserve the card.</p>

	<p>The second method involves using a hacked version of the Barcode Taisen Bardigun ROM on a flashcart to save incoming Serial I&#47;O data as a card is scanned. The binary can be pulled from a save file. Both binary files could be used an input to feed back to an emulator.</p>

	<!-- DMG-07 -->

	<a name="dmg07_gen"></a>
	<p class="gray_title">[DMG-07] : General Hardware Information</p>

	<p>The DMG-07 is an accessory that allows 4 Game Boys to connect for multiplayer. In the West, it first appeared with the game F-1 Race as bundle in 1990. Only a few other games took advantage of the DMG-07 (namely Wave Race and Faceball 2000, Yoshi&#39;s Cookie) and it did not see widespread support at all.</p>

	<ul>
		<li class="list_item">DMG-07 is a gray &#34;hub&#34; with 3 input ports for Gen 1 Link Cables.</li>
		<li class="list_item">DMG-07 is largely designed for Gen 1 Link Cables and DMG models. MGB-010s allow any Game Boy (up to the Micro) to connect as Players 2-4.</li>
		<li class="list_item">Player 1 comes with a built-in cable (Gen 1). All other players need extra cables.</li>
		<li class="list_item">Player 1 needs to be a DMG model unless an MGB-004 adapter is used.</li>
		<li class="list_item">DMG-07 uses a Motorola 402038 for multiplexing stuff.</li>
	</ul>

	<a name="dmg07_gam"></a>
	<p class="gray_title">[DMG-07] : Compatible Games</p>

	<ul>
		<li class="list_item">Chachamaru Panix</li>
		<li class="list_item">Downtown Nekketsu Koushinkyoku: Dokodemo Daiundoukai</li>
		<li class="list_item">Faceball 2000</li>
		<li class="list_item">F1 Race</li>
		<li class="list_item">F1 Pole Position</li>
		<li class="list_item">Nekketsu Koukou Dodge Ball-Bu</li>
		<li class="list_item">Super R.C. Pro-Am</li>
		<li class="list_item">Top Rank Tennis</li>
		<li class="list_item">Trax</li>
		<li class="list_item">Trump Boy II</li>
		<li class="list_item">Uno: Small World 2</li>
		<li class="list_item">Wave Race</li>
		<li class="list_item">Yoshi&#39;s Cookie</li>
	</ul>

	<a name="dmg07_pro"></a>
	<p class="gray_title">[DMG-07] : Link Cable Protocol</p>

	<p>The DMG-07 protocol can be divided into 2 sections, the &#34;ping&#34; phase, and the &#34;transmission&#34; phase. The initial ping phase involves sending packets back and forth between connected Game Boys probing for their current connection status. Afterwards, the DMG-07 enters into transmission mode where the Game Boys exchange data across the network.</p>

	<p>A very important thing to note is that all Game Boys transfer data across the DMG-07 via an external clock source. Apparently, the clock source is provided by the DMG-07 itself. Trying to send data via an internal clock results in garbage data.</p>

	<a name="dmg07_pin"></a>
	<p class="gray_title">[DMG-07] : Ping Phase</p>

	<p>When a &#34;master&#34; Game Boy (Player 1) is first connected to the DMG-07, setting Bit 7 of 0xFF02 to 1 and setting Bit 0 of 0xFF02 to 0 causes the accessory to send out "ping" packets periodically. All connected Game Boys will receive 4 bytes as part of the ping packet, at a rate of about 2048 bits-per-second, or about 256 bytes-per-second. Essentially, the ping seems to run 1&#47;4 as fast as the clock used for normal serial transfers on the DMG (1KB&#47;s). The ping data looks like this:</p>

	<code>0xFE		ID Byte
0x??		STAT1
0x??		STAT2
0x??		STAT3</code>

	<p>3 &#34;STAT&#34; bytes are sent indicating the current connection status of the other Game Boys. Each byte is usually the same, however, sometimes the status can change mid-way through a ping, typically on STAT2 or STAT3. Each STAT byte looks like such:</p>

	<code>Bit 0-2: 	Player ID
Bit 4:		Player 1 Connected
Bit 5:		Player 2 Connected
Bit 6:		Player 3 Connected
Bit 7:		Player 4 Connected</code>

	<p>The Player ID is simply a value of 1-4. Its value is determined by whichever port a Game Boy is connected to. As more Game Boys connect, the upper bits of the STAT bytes are turned on.</p>

	<p>When talking about Game Boys and the &#34;connection&#34;, this refers to a Game Boy properly responding to STAT1 and STAT2 bytes when receiving a ping packet from the DMG-07. In this way, the Game Boy broadcasts across the Link Cable network that it is an active participant in communications. It also acts as a sort of acknowledgement signal, where software can drop a Game Boy if the DMG-07 detects an improper response during a ping, or a Game Boy simply quits the network. The proper response is to send 0x88 *after* receiving the ID Byte and STAT1, in which case the upper-half of STAT1, STAT2, and STAT3 are updated to show that a Game Boy is &#34;connected&#34;. If for whatever reason, the acknowledgement codes are not sent, the above bits are unset.</p>

	<p>Some examples of ping packets are shown below:</p>

	<code>0xFE 0x01 0x01 0x01	-&gt;	Ping packet received by Player 1 with no other Game Boys connected
0xFE 0x11 0x11 0x11	-&gt;	Ping packet received by Player 1 when Player 1 has connected
0xFE 0x31 0x31 0x31	-&gt;	Ping packet received by Player 1 when Players 1 & 2 have connected
0xFE 0x71 0x71 0x71	-&gt;	Ping packet received by Player 1 when Players 1, 2, & 3 have connected
0xFE 0x62 0x62 0x62	-&gt;	Ping packet received by Player 2 when Players 2 & 3 are connected (but not Player 1)</code>

	<p>It&39;s possible to have situations where some players are connected but others are not; the gaps don&#39;t matter. For example, Player 1 and Player 4 can be connected, while Player 2 and Player 3 can be disconnected (or non-existant, same thing); most games do not care so long as Player 1 is active, as that Game Boy acts as master and orchestrates the multiplayer session from a software point of view. Because of the way the DMG-07 hardcodes player IDs based on which port a Game Boy is physically connected to, in the above situation Player 4 wouldn&#39;t suddenly become Player 2 in a game like F-1 Race.</p>

	<p>During the ping phase, the master Game Boy is capable of setting up two parameters that will be used during the transmission phase. The clock rate for the transmission phase can be adjusted, as well as the packet size each Game Boy will use. The master Game Boy needs to respond with one byte for STAT2 and STAT3 respectively. The chart below illustrates how a master Game Boy should respond to all bytes in a ping packet:</p>

<code>----------------------------
DMG-07		Game Boy
----------------------------
0xFE	&lt;--&gt;	(ACK1) = 0x88
STAT1	&lt;--&gt;	(ACK2) = 0x88	
STAT2	&lt;--&gt;	(RATE) = Link Cable Speed 
STAT3	&lt;--&gt;	(SIZE) = Packet Size</code>

	<p>The new clock rate is only applied when entering the transmission phase; the ping phase runs at a constant 2048 bits-per-second. The formula for the new clock rate is as follows:</p>

<code>DMG-07 Bits-Per-Second --&gt; 4194304 &#47; ((6 * RATE) + 512)</code>

	<p>The lowest setting (RATE = 0) runs the DMG-07 at the normal speed DMGs usually transfer data (1KB&#47;s), while setting it to 0xFF runs its close to the slowest speed (2042 bits-per-second).</p>

	<p>SIZE sets the length of packets exchanged between all Game Boys. Nothing fancy, just the number of bytes in each packet. It probably shouldn&#39;t be set to zero.</p>

	<a name="dmg07_tra"></a>
	<p class="gray_title">[DMG-07] : Transmission Phase</p>

	<p>When the master Game Boy (Player 1) is ready, it should send 4 bytes (0xAA 0xAA 0xAA 0xAA). Some games only send 3 bytes however (0xAA 0xAA 0xAA and 0x00). This alerts the DMG-07 to start the transmission phase. The RATE and SIZE parameters are applied at this point. The protocol is simple: Each Game Boy sends a packet to the DMG-07 simultaneously, then the DMG-07 outputs each packet to all connected Game Boys. All data is buffered, so there is a 4 packet delay after each Game Boy submits their data (the delay is still 4 packets long even if some Game Boys are not connected). For example, say the packet size is 4 bytes; the flow of data would look like this when sending:</p>


<code>--------------------------------------------------------------------------------------------
P1 send		P2 send		P3 send		P4 send		Transfer count
--------------------------------------------------------------------------------------------
P1_byte_1	P2_byte_1	P3_byte_1	P4_byte_1	0
P1_byte_2	P2_byte_2	P3_byte_2	P4_byte_2	1
P1_byte_3	P2_byte_3	P3_byte_3	P4_byte_3	2
P1_byte_4	P2_byte_4	P3_byte_4	P4_byte_4	3

0		0		0		0		4 (Typically supposed to be zero, but DMG-07 ignores anything here)
0		0		0		0		5
0		0		0		0		6
0		0		0		0		7

0		0		0		0		8
0		0		0		0		9
0		0		0		0		10
0		0		0		0		11

0		0		0		0		12
0		0		0		0		13
0		0		0		0		14
0		0		0		0		15</code>

	<p>And when receiving, the flow of data would look like this:</p>

<code>--------------------------------------------------------------------------------------------
P1 recv		P2 recv		P3 recv		P4 recv		Transfer count
--------------------------------------------------------------------------------------------
P1_byte_1	P1_byte_1	P1_byte_1	P1_byte_1	16
P1_byte_2	P1_byte_2	P1_byte_2	P1_byte_2	17
P1_byte_3	P1_byte_3	P1_byte_3	P1_byte_3	18
P1_byte_4	P1_byte_4	P1_byte_4	P1_byte_4	19

P2_byte_1	P2_byte_1	P2_byte_1	P2_byte_1	20
P2_byte_2	P2_byte_2	P2_byte_2	P2_byte_2	21
P2_byte_3	P2_byte_3	P2_byte_3	P2_byte_3	22
P2_byte_4	P2_byte_4	P2_byte_4	P2_byte_4	23

P3_byte_1	P3_byte_1	P3_byte_1	P3_byte_1	24
P3_byte_2	P3_byte_2	P3_byte_2	P3_byte_2	25
P3_byte_3	P3_byte_3	P3_byte_3	P3_byte_3	26
P3_byte_4	P3_byte_4	P3_byte_4	P3_byte_4	27

P4_byte_1	P4_byte_1	P4_byte_1	P4_byte_1	28
P4_byte_2	P4_byte_2	P4_byte_2	P4_byte_2	29
P4_byte_3	P4_byte_3	P4_byte_3	P4_byte_3	30
P4_byte_4	P4_byte_4	P4_byte_4	P4_byte_4	31</code>

	<p>Again, due to buffering, data output to the DMG-07 is actually delayed by several transfers according to the size of the packets. All connected Game Boys should send their data into the buffer during the first few transfers. Here, the packet size is 4 bytes, so each Game Boy should submit their data during the first 4 transfers. The other 12 transfers don&#39;t care what the Game Boys send; it won&#39;t enter into the buffer. The next 16 transfers return the packets each Game Boy previously sent (if no Game Boy exists for player, that slot is filled with zeroes).</p>

	<p>With the buffering system, Game Boys would normally be reading data from previous packets during transfers 0-15, in addition to sending new packets. Likewise, during transfers 16-19 each Game Boy is sending new packets. In effect, while receiving old data, Game Boys are supposed to pump new data into the network.</p>

	<p>When the DMG-07 enters the transmission phase, the buffer is initially filled with garbage data that is based on output the master Game Boy had sent during the ping phase. At this time, it is recommended to ignore the earliest packets received, however, it is safe to start putting new, relevant data into the buffer.</p>

	<a name="dmg07_res"></a>
	<p class="gray_title">[DMG-07] : Restarting Ping Phase</p>

	<p>It&#39;s possible to restart the ping phase while operating in the transmission phase. To do so, the master Game Boy should send 4 or more bytes (0xFF 0xFF 0xFF 0xFF). Again, some games send less (0xFF 0xFF 0xFF and 0x00). It&#39;s possible only 1 or 2 0xFF bytes need to be sent, but this has not been extensively investigated yet. At any rate, the bytes alert the DMG-07 that the ping phase should begin again. Most games use this to end the multiplayer session and return to the title screen. For example, in F-1 Race, the game automatically jumps back to the title screen after all races have been completed, while Wave Race has a menu to continue playing or end the session. In either case, the games send 0xFF bytes and the DMG-07 sends ping packets after a brief delay. During this delay, the transmission protocol is still working as intended until the switch happens.</p>

	<!-- Zok Zok Heroes Full Changer -->

	<a name="zzh_gen"></a>
	<p class="gray_title">[Full Changer] : General Hardware Information</p>

	<p>Zok Zok Heroes was a GBC JRPG released on August 4, 2000, made by Media Factory when they still produced video games. It used a special accessory called the &#34;Full Changer&#34;, a device that looks like a toy, but acts as an IR transmitter. It sent signals to the GBC once players moved it through the air to &#34;draw&#34; certain patterns. Once the GBC gets the IR light pulses, it allows players to transform into different &#34;Bright Heroes&#34; to do battle against evil bad guys. It never sold outside of Japan. After a specific point early in the game, it becomes impossible to progress further in emulators without cheat codes&#47;hacks or by properly emulating the Full Changer.</p>

	<ul>
		<li class="list_item">Zok Zok Heroes (CGB-BZHJ-JPN)</li>
		<li class="list_item">MBC5 + Battery Saves</li>
		<li class="list_item">GBC Only</li>
		<li class="list_item">Comes with 1 Full Changer accessory</li>
		<li class="list_item">Full Changer uses one CR2032</li>
		<li class="list_item">Full Changer presumably contains an accelerometer to detect movement</li>
		<li class="list_item">Full Changer has a series of status lights and blinks&#47;beeps when swung correctly</li>
	</ul>

	<a name="zzh_opr"></a>
	<p class="gray_title">[Full Changer] : Operation</p>

	<ol>
		<li>Grab the Full Changer firmly, holding it by the strap</li>
		<li>Press and release the top button. It should beep and the 3 lights should flash for approximately 5 seconds.</li>
		<li>During those 5 seconds, move the Full Changer to draw the pattern of a &#34;Cosmic Character&#34; e.g. for &#34;Z&#34; start left, move right, stop, move downward and leftward, stop, move right, stop.</li>
		<li>Make sure the Full Changer is always held upright while drawing.</li>
		<li>For each successful movement, the Full Changer will activate another light and beep. Once all three at lit, it beeps a little tune and the data is ready to be sent to the GBC.</li>
		<li>Put the bottom of the Full Changer on top of the GBC, making sure to cover the IR port. The Full Changer has a little plastic guide to make sure everything fits and faces the right direction.</li>
	</ol>

	<a name="zzh_com"></a>
	<p class="gray_title">[Full Changer] : IR Communication</p>

	<p>The Full Changer sends a total of 18 IR pulses (ON then OFF periods) when transmitting data. The length of these pulses varies and determines what values the Full Changer is trying to send. Zok Zok Heroes runs in a couple of loops while the pulse takes place. Each iteration, it increments a counter to get an idea of the overall &#34;delay&#34; it takes for the IR light to turn on then turn off. That counter is then placed in WRAM as a single byte (anything greater than 0xFF causes a timeout) and verified later. In this way, Zok Zok Heroes can view data from the Full Changer as a series of bytes rather than light pulses. These 18 bytes do not appear to have to be especially strict values (e.g. changing them +1 or -1 should still yield the same Bright Hero transformation). The overall data format, if any, is currently unknown, making it difficult to determine what those 18 bytes should be without intercepting an actual transmission from the Full Changer (this could change in the future with more analysis).</p>

	<a name="zzh_cap"></a>
	<p class="gray_title">[Full Changer] : Capturing IR Data</p>

	<p>Below is the disassembled GBZ80 code Zok Zok Heroes uses to grab the 18 bytes:</p>

<code>&#47;&#47;This all happens at ROM Bank 1
&#47;&#47;Wait for IR light to come on (Bit 1 of 0xFF46 goes to zero)
&#47;&#47;D is set to 0xFF, timeout if it reaches zero
DEC D
RET Z
LDH A, (0xFF56)
BIT 1, A
JR NZ, 0xF9

&#47;&#47;E acts as a counter for total number of bytes processed from Full Changer
LD E 0x12
LD HL, 0xD005

&#47;&#47;Wait for IR light to go off (Bit 1 of 0xFF46 goes to one)
LD D, 0x00
CALL 0x575E
	INC D
	RET Z
	LDH A, (0xFF56)
	BIT 1, A
	JR Z, 0xF9
	RET

&#47;&#47;Wait for IR light to go on (Bit 1 of 0xFF46 goes to one)
CALL 0x576C
	INC D
	RET Z
	LDH A, (0xFF56)
	BIT 1, A
	JR NZ, 0xF9
	RET

&#47;&#47;Save results to 0xD005 - 0xD017
LD (HL), D
INC HL
DEC E

&#47;&#47;Jump back to LD, 0x00. Repeat loop until E is zero.
JR NZ, 0xF3</code>

	<p>Once all 18 bytes have been stored in WRAM, it&#39;s possible to read them and save them using a ROM hack. Alternatively, homebrew software can use code with the same timing to accurately capture IR data from the Full Changer.</p>

	<a name="zzh_emu"></a>
	<p class="gray_title">[Full Changer] : Emulation</p>

	<p>The Full Changer can be successfully emulated by setting Bit 1 of RP register (located at 0xFF56) to 0 or 1 at the appropiate times. To do so requires accurate timing and knowing the amount of cycles it takes to generate the delays represented by those 18 bytes in WRAM. When activating the Full Changer, GBE+ always fires the 1st &#34;ON&#34; IR signal at a specific time to get consistent timings:</p>

<code>DEC D
RET Z
LDH A, (0xFF56)

<---- After the CPU reads 0xFF56 and the user activates the Full Changer, IR light is turned on here
<---- This happens after the actual instruction is executed, so the loop runs once more

BIT 1, A
JR NZ, 0xF9</code>

	<p>Afterwards, the timings for ON and OFF pulses can be calculated as such (ALL TIMING IS IN DOUBLE SPEED):</p>

<code>Afterwards, the timings for ON and OFF pulses can be calculated as such (ALL TIMING IS IN DOUBLE SPEED):

1st ON pulse length			74 + (20 * (LENGTH-2))

Every other ON pulse length		78 + (20 * (LENGTH-2))

OFF pulse length			38 + (20 * (LENGTH-2))</code>

	<p>The LENGTH is number of times the CPU register D is incremented at 0x575E or 0x576C. The sum two LENGTHs from one ON pulse and one OFF pulse must be equal to the delay data in WRAM. For example, say the delay data contains 0x30. This means that the TOTAL amount of times D was incremented is 0x30. In a perfect world, the Full Changer would probably turn on the IR light so that D is incremented 0x18 times, then turn off the IR light so that D is incremented again 0x18 times. In reality, however, the length of the ON&#47;OFF pulses could run a bit longer or shorter. As far as Zok Zok Heroes is concerned, the total amount of time the IR light is ON then OFF is what matters, so the ON&#47;OFF pulse timings ultimately have to add up.</p>

	</p>The current database GBE+ uses recreates ON&#47;OFF pulses that generally run for the same amount of cycles. However, based on hardware tests, the ON pulses have variable lengths, while the OFF pulses are typically constant. Again, Zok Zok Heroes won&#39;t care, as long as the total time of the ON&#47;OFF pulses meets whatever value it expects.</p>

	<!-- GBA Screen Stretch -->
	<a name="gss_gen"></a>

	<p class="gray_title">GBA Screen Stretch</p>

	<p>GBA hardware has the ability to stretch the final image drawn on-screen when running DMG or GBC games. On applicable hardware (e.g. not the Micro, original NDS, or NDS Lite models), the L and R triggers toggle this feature on and off respectively. The default mode is to display the DMG&#47;GBC image in the middle of the GBA screen with black borders. The dimensions are as follows:</p>

<code>Top and bottom borders (240x8 pixels, or 30x1 tiles)
Left and right borders (40x160 pixels, or 5x20 tiles)
DMG/GBC screen (160x144 pixels, or 20x18 tiles)</code>

	<p>Technically, the original DMG&#47;GBC screen has an offset of (40, 8). Once the player toggles stretching, the above dimensions change:</p>

<code>Top and bottom borders (240x8 pixels, or 30x1 tiles)
Left and right borders (Not Applicable)
DMG/GBC screen (240x144 pixels, or 30x18 tiles)</code>

	<p>The DMG&#47;GBC screen completely stretches to the left and right ends of the screen. No vertical stretching occurs; the black bars still exist at the top and the bottom. Horizontal stretching follows a simple formula. For every 2 pixels from the original 160x144 image, a third pixel is generated by blending them together. This third pixel is then placed between the two original pixels. For example, imagine Pixel A and Pixel B represent original pixels from the 160x144 image. Pixel C is the result of blending the two of them. The GBA will produce A-C-B when stretching DMG and GBC games.</p>

	<p>This method of stretching acts on the present 160x144 image generated by the DMG/GBC game, that is to say, scrolling the background, window, or OBJs can produce minor inconsistencies depending on where a tile is rendered to the screen. Generally, these inconsistencies affect the blending seen around edges. For example, in the first level of Super Mario Land, the trunks of the trees in the background are only 1 pixel wide. When stretching, the blended edge will switch from the left to the right depending on its current position due to scrolling. However, these inconsistencies are barely visible under the best circumstances, and almost impossible to detect during actual gameplay.</p>

	<p>The blending comes straight from the GBA&#39;s affine transformations. That is to say, after the final DMG&#47;GBC screen is rendered, the GBA controls all output via BG2. Even in the GBA&#39;s DMG&#47;GBC backward compatibility mode, GBA video hardware is still being used to display graphics. Currently, the exact formula for determining colors remains unknown, however, something as simple as averaging Pixel A and Pixel B gives quick, adequately believable results. One thing that is known about the blending: if A and B are the same color, they will not produce a different color.</p>

</html>					